1.实现了二叉树的删除最大值和最小值的方法
	最小值的特点是在整个二叉树的最左下角，也就是说最小值的左子节点为空，删除最小值的同时还需要做的就是将右子节点放到要删除节点的位置
	思路是左子节点是否为空，为空的话代表已经找到了二叉树中的最小节点，然后取到这个节点的右子节点，然后将右子节点置空，然后count--,然后返回右子节点，这时右子节点已经了替换了要删除节点的位置
	另外一种情况：如果左子节点不为空的话，继续递归调用自己，参数是左子节点，得到的返回值赋值给左子节点，最后函数返回整个删除函数传入的参数node即可。

2.实现了二叉树中的删除任意节点的方法：
	思路和删除最大小值的思路很相似，区别在于任意节点不像是最大小值节点，任意节点有可能是左右子节点都不为空，而最大小值节点的子节点只有一个。
	思路是判断传入的key值如果比当前节点的key值小的话继续递归调用自己，大的话也是一样。如果key和当前节点的key相等的话，这个节点也就是需要删除的节点，这时判断当前节点左子节点是否为空，
	为空的话将右子节点取到然后置空，最后返回右子节点。右子节点为空的话同理。
	最后一种重要的情况时左右子节点都不为空，这时重要的问题是需要用哪个节点替换当前需要删除的节点，这个节点应该满足的条件是大于左子节点所有节点，小于右子节点所有节点。
	所以可以确定取到右子节点的最小值即可，然后调用minimum将右子节点作为参数传入得到右子节点下的最小值，count++,然后将这个节点的左右子节点为别赋值，赋值右子节点时应该是调用remove(node.right)
	赋值完成以后将原来的左右子节点置空，count--，然后返回新的刚刚赋值的节点就可。

3.实现了观察者设计模式
	观察者模式在java中有具体的实现，只不过主题是一个类而不是接口，导致了功能使用会受到限制，比如子类想要继承其他父类的话无法实现多继承，但是观察者模式的正常的功能都能够使用。
	使用方法是写具体的观察者类继承观察者父类，直接利用父类的新增观察者，删除观察者，通知方法，也不需要写一个具体的观察者集合，可以写一个set方法和多个get方法，set用于外界设置主题的的改变
	，多个get方法用于外界调用来实现拉模型的方式获取观察者自己想要得到的定制数据。而且在通知方法调用之前需要先调用setChanged方法，这个方法可用于通知方法的控制调用。
	
	而观察者一方只需要写具体的观察者实现类并实现观察者接口，实现update方法即可，可以自己写一个display接口供观察者具体类实现，表现自己不同的展现数据的方式，update方法有主题对象的参数，
	通过这个参数可以通过拉模型拿到主题的具体数据，前提要求是需要有一个主题的成员变量，然后在观察者的构造方法中初始化主题变量。

	观察者模式很好的实现了观察者和主题之间的松耦合，也诠释了面向接口编程的特点，因为主题只是依赖于一个接口，而不知道具体的观察者的实现是谁，所以一旦需要
  增加新的观察者或者改变观察者主题完全不知道也无需知道，所以观察者的改变不会影响到主题的代码，实现了松耦合。
