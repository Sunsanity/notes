知识点
1.JS type类型
  1.undefined
  2.字符串
  3.数字
  4.boolean
  5.function
  6.Object(对象，数组，null)

2.JS中的对象不管怎样赋值都只是一个对象，给多个引用变量赋值只代表有多个指针指向了同一个对象，所以一旦对象的属性发生变化，所有指向这个对象的引用获取到
的对象属性都会发生变化。

3.JS中的对象其实都是通过函数创建出来的，而函数又是一个对象，对象其实就是属性的集合。JS中的所有函数都有一个prototype属性，叫做显式原型，这个原型属性的
值是一个对象，这个对象又是多个属性的集合，其中有一个属性是constructor，这个属性指向了函数本身。我们也可以自己加入别的属性。那这个函数的原型有什么用处？
这个原型的用处还是体现在对象的创建上，因为对象的创建会调用一个函数，所以这个对象就应该可以调用这个函数中的prototype中的任何属性,因为每个对象都有一个
__proto__属性，fn.__proto__ === Fn.prototype，所以对象是可以调用函数中的任何属性的。这样也就让这个对象不仅仅有了属性，同时也有了一些自己的方法。
这个__proto__叫做对象的隐式原型。

4.js中的继承和java不同，java中的继承是子类继承父类，而js中的继承是所有的对象(除了Object)的__proto__都指向了Object.prototype,所以所有对象都可以
调用Object.prototype中的方法，其中就包括hasOwnProperty方法。另外所有的函数也是一样，__proto__都指向了Function.prototype，所以所有函数也都可以
调用Function.prototype的方法和属性。js中的继承就是通过这种原型链来体现的。
var f1 = new Foo();
f1.a = 10;
Foo.prototype.a = 100;
Foo.prototype.a = 200;
console.log(f1.a) //10
console.log(f1.b) //200
f1.hasOwnProperty(a)  //true
f1.hasOwnProperty(b)  //false
其中b这个属性其实是通过原型链向外查找找到的，而a是这个对象的基本属性，那么就可以通过f1.hasOwnProperty(a)这个方法判断a是f1的基本属性还是通过原型链
找到的属性。JS中一个对象如果有一个基本属性和通过原型找到的属性一样，JS会先查找基本属性，没有找到的话才会沿着原型链找这个属性。

5.浏览器在执行JS中的代码段（1.全局代码（<script type=text/javascript>） 2.eval函数中的代码 3.函数中的代码）以前会做一些准备工作
（这些准备工作叫做执行上下文）：
  1.变量和函数表达式的声明（不会赋值,函数表达式会被当做赋值操作对待）  
  2.this的赋值 
  3.函数的赋值
console.log(a); //a is not defined

console.log(a); //undefined 对a进行声明，但是未赋值
var a = 1;

console.log(Foo); //function Foo();
function Foo(){
}

console.log(FooFunction); undefined
var FooFunction = function Foo(){
}
