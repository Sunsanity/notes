1.实现了二叉树的两种遍历方式：
	深度优先遍历：1.前序遍历 2.中序遍历 3.后续遍历
		三种方式都用递归实现，区别就是当前元素的输出顺序，设想每个节点都有两条线和三个点，前中后三个点代表前中后序的三个位置。注意中序遍历的输出顺序正好是整个数组的正序排列的顺序。
		所以我们可以利用二叉树的中序遍历实现一个数组的正序排序。后序遍历的意义是用于资源的释放操作，比如c++中的稀构操作。

	广度优先遍历：又叫做层序遍历，区别于深度优先遍历的是深度优先遍历是一直向深处钻，然后返回，而层序优先遍历是一层一层的遍历。

2.学习了策略模式
	策略模式解决了多种实体有相似的行为方法，这时可以利用策略模式，策略模式定义就是将不会发生变化的部分和会发生变化的部分分离开来，鸭子飞行举例来说不变的部分就是飞行这个行为，
	我们将这个不会发生变化的部分定义为一个接口，具体的飞行方式就是会发生变化的部分，这些不同的飞行行为定义为不同的具体实现类，这些实现类同时实现飞行接口，实现飞行这个方法。
	然后具体的鸭子实现类就可以利用不同的飞行实现类，将具体实现类传递给鸭子抽象父类，鸭子抽象父类中有飞行接口这个私有属性和set方法，并为所有的鸭子子类提供了飞行方法供子类调用，
	这个方法实际上调用的就是子类传入进来的飞行子类的飞行方法，这样做的好处
	1.代码有足够的灵活性和可扩展性，以后有新的鸭子子类可以直接继承父类，然后提供一个需要的飞行子类就可以实现飞行。
	2.代码复用性更强，新的鸭子子类只需要提供合适的飞行子类就可以了，不用重新编写自己的具体飞行方法。
	3.不同飞行类的变化不会影响到程序的运行，需要变化飞行类的方法时可以直接新增一个飞行类而不用去改以前的代码。
	4.策略模式很好的表达了开发中需要面向接口编程而不是面向实现编程。
